# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_range_dhcpd__dhcp_subNetworks_subNetwork_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dhcpd - based on the path /dhcp/subNetworks/subNetwork/range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A range of IP addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dynamicBootP','__lowAddr','__hiAddr',)

  _yang_name = 'range'
  _yang_namespace = 'http://univ-tlse3.fr/ns/dhcpd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dynamicBootP = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dynamicBootP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='boolean', is_config=True)
    self.__lowAddr = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lowAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    self.__hiAddr = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="hiAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['dhcp', 'subNetworks', 'subNetwork', 'range']

  def _get_dynamicBootP(self):
    """
    Getter method for dynamicBootP, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/dynamicBootP (boolean)

    YANG Description: Addresses in this range may be dynamically assigned
to BOOTP clients (as well as DHCP clients).
    """
    return self.__dynamicBootP
      
  def _set_dynamicBootP(self, v, load=False):
    """
    Setter method for dynamicBootP, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/dynamicBootP (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamicBootP is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamicBootP() directly.

    YANG Description: Addresses in this range may be dynamically assigned
to BOOTP clients (as well as DHCP clients).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dynamicBootP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamicBootP must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dynamicBootP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='boolean', is_config=True)""",
        })

    self.__dynamicBootP = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamicBootP(self):
    self.__dynamicBootP = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="dynamicBootP", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='boolean', is_config=True)


  def _get_lowAddr(self):
    """
    Getter method for lowAddr, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/lowAddr (inet:ipv4-address)

    YANG Description: Lower address of this range.
    """
    return self.__lowAddr
      
  def _set_lowAddr(self, v, load=False):
    """
    Setter method for lowAddr, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/lowAddr (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lowAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lowAddr() directly.

    YANG Description: Lower address of this range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lowAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lowAddr must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lowAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__lowAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lowAddr(self):
    self.__lowAddr = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="lowAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)


  def _get_hiAddr(self):
    """
    Getter method for hiAddr, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/hiAddr (inet:ipv4-address)

    YANG Description: Higher address of this range.
    """
    return self.__hiAddr
      
  def _set_hiAddr(self, v, load=False):
    """
    Setter method for hiAddr, mapped from YANG variable /dhcp/subNetworks/subNetwork/range/hiAddr (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hiAddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hiAddr() directly.

    YANG Description: Higher address of this range.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="hiAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hiAddr must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="hiAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__hiAddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hiAddr(self):
    self.__hiAddr = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="hiAddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)

  dynamicBootP = __builtin__.property(_get_dynamicBootP, _set_dynamicBootP)
  lowAddr = __builtin__.property(_get_lowAddr, _set_lowAddr)
  hiAddr = __builtin__.property(_get_hiAddr, _set_hiAddr)


  _pyangbind_elements = OrderedDict([('dynamicBootP', dynamicBootP), ('lowAddr', lowAddr), ('hiAddr', hiAddr), ])


class yc_subNetwork_dhcpd__dhcp_subNetworks_subNetwork(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dhcpd - based on the path /dhcp/subNetworks/subNetwork. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A subnet that can be assigned by the DHCP server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__net','__mask','__range','__routers','__maxLeaseTime',)

  _yang_name = 'subNetwork'
  _yang_namespace = 'http://univ-tlse3.fr/ns/dhcpd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__net = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    self.__range = YANGDynClass(base=yc_range_dhcpd__dhcp_subNetworks_subNetwork_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)
    self.__routers = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='string', is_config=True)
    self.__maxLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['dhcp', 'subNetworks', 'subNetwork']

  def _get_net(self):
    """
    Getter method for net, mapped from YANG variable /dhcp/subNetworks/subNetwork/net (inet:ipv4-address)

    YANG Description: The subnet IP address.
    """
    return self.__net
      
  def _set_net(self, v, load=False):
    """
    Setter method for net, mapped from YANG variable /dhcp/subNetworks/subNetwork/net (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_net is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_net() directly.

    YANG Description: The subnet IP address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """net must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__net = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_net(self):
    self.__net = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="net", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /dhcp/subNetworks/subNetwork/mask (inet:ipv4-address)

    YANG Description: The mask of the subnet.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /dhcp/subNetworks/subNetwork/mask (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: The mask of the subnet.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)


  def _get_range(self):
    """
    Getter method for range, mapped from YANG variable /dhcp/subNetworks/subNetwork/range (container)

    YANG Description: A range of IP addresses.
    """
    return self.__range
      
  def _set_range(self, v, load=False):
    """
    Setter method for range, mapped from YANG variable /dhcp/subNetworks/subNetwork/range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range() directly.

    YANG Description: A range of IP addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_range_dhcpd__dhcp_subNetworks_subNetwork_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_range_dhcpd__dhcp_subNetworks_subNetwork_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)""",
        })

    self.__range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_range(self):
    self.__range = YANGDynClass(base=yc_range_dhcpd__dhcp_subNetworks_subNetwork_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)


  def _get_routers(self):
    """
    Getter method for routers, mapped from YANG variable /dhcp/subNetworks/subNetwork/routers (string)

    YANG Description: Default router
    """
    return self.__routers
      
  def _set_routers(self, v, load=False):
    """
    Setter method for routers, mapped from YANG variable /dhcp/subNetworks/subNetwork/routers (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routers() directly.

    YANG Description: Default router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="routers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routers must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='string', is_config=True)""",
        })

    self.__routers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routers(self):
    self.__routers = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="routers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='string', is_config=True)


  def _get_maxLeaseTime(self):
    """
    Getter method for maxLeaseTime, mapped from YANG variable /dhcp/subNetworks/subNetwork/maxLeaseTime (uint32)

    YANG Description: The max lease time (specific to this range).
    """
    return self.__maxLeaseTime
      
  def _set_maxLeaseTime(self, v, load=False):
    """
    Setter method for maxLeaseTime, mapped from YANG variable /dhcp/subNetworks/subNetwork/maxLeaseTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLeaseTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLeaseTime() directly.

    YANG Description: The max lease time (specific to this range).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLeaseTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)""",
        })

    self.__maxLeaseTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLeaseTime(self):
    self.__maxLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)

  net = __builtin__.property(_get_net, _set_net)
  mask = __builtin__.property(_get_mask, _set_mask)
  range = __builtin__.property(_get_range, _set_range)
  routers = __builtin__.property(_get_routers, _set_routers)
  maxLeaseTime = __builtin__.property(_get_maxLeaseTime, _set_maxLeaseTime)


  _pyangbind_elements = OrderedDict([('net', net), ('mask', mask), ('range', range), ('routers', routers), ('maxLeaseTime', maxLeaseTime), ])


class yc_subNetworks_dhcpd__dhcp_subNetworks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dhcpd - based on the path /dhcp/subNetworks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__subNetwork',)

  _yang_name = 'subNetworks'
  _yang_namespace = 'http://univ-tlse3.fr/ns/dhcpd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subNetwork = YANGDynClass(base=YANGListType("net mask",yc_subNetwork_dhcpd__dhcp_subNetworks_subNetwork, yang_name="subNetwork", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='net mask', extensions=None), is_container='list', yang_name="subNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['dhcp', 'subNetworks']

  def _get_subNetwork(self):
    """
    Getter method for subNetwork, mapped from YANG variable /dhcp/subNetworks/subNetwork (list)

    YANG Description: A subnet that can be assigned by the DHCP server.
    """
    return self.__subNetwork
      
  def _set_subNetwork(self, v, load=False):
    """
    Setter method for subNetwork, mapped from YANG variable /dhcp/subNetworks/subNetwork (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subNetwork is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subNetwork() directly.

    YANG Description: A subnet that can be assigned by the DHCP server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("net mask",yc_subNetwork_dhcpd__dhcp_subNetworks_subNetwork, yang_name="subNetwork", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='net mask', extensions=None), is_container='list', yang_name="subNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subNetwork must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("net mask",yc_subNetwork_dhcpd__dhcp_subNetworks_subNetwork, yang_name="subNetwork", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='net mask', extensions=None), is_container='list', yang_name="subNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='list', is_config=True)""",
        })

    self.__subNetwork = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subNetwork(self):
    self.__subNetwork = YANGDynClass(base=YANGListType("net mask",yc_subNetwork_dhcpd__dhcp_subNetworks_subNetwork, yang_name="subNetwork", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='net mask', extensions=None), is_container='list', yang_name="subNetwork", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='list', is_config=True)

  subNetwork = __builtin__.property(_get_subNetwork, _set_subNetwork)


  _pyangbind_elements = OrderedDict([('subNetwork', subNetwork), ])


class yc_dhcp_dhcpd__dhcp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dhcpd - based on the path /dhcp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: DHCP server configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defaultLeaseTime','__maxLeaseTime','__logFacility','__dns','__subNetworks',)

  _yang_name = 'dhcp'
  _yang_namespace = 'http://univ-tlse3.fr/ns/dhcpd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defaultLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="defaultLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)
    self.__maxLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)
    self.__logFacility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'kern': {}, 'daemon': {}, 'local7': {}},), default=six.text_type("local7"), is_leaf=True, yang_name="logFacility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='loglevel', is_config=True)
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    self.__subNetworks = YANGDynClass(base=yc_subNetworks_dhcpd__dhcp_subNetworks, is_container='container', yang_name="subNetworks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['dhcp']

  def _get_defaultLeaseTime(self):
    """
    Getter method for defaultLeaseTime, mapped from YANG variable /dhcp/defaultLeaseTime (uint32)

    YANG Description: The default lease time (global parameter).
    """
    return self.__defaultLeaseTime
      
  def _set_defaultLeaseTime(self, v, load=False):
    """
    Setter method for defaultLeaseTime, mapped from YANG variable /dhcp/defaultLeaseTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defaultLeaseTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defaultLeaseTime() directly.

    YANG Description: The default lease time (global parameter).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="defaultLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defaultLeaseTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="defaultLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)""",
        })

    self.__defaultLeaseTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defaultLeaseTime(self):
    self.__defaultLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(600), is_leaf=True, yang_name="defaultLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)


  def _get_maxLeaseTime(self):
    """
    Getter method for maxLeaseTime, mapped from YANG variable /dhcp/maxLeaseTime (uint32)

    YANG Description: The max lease time (global parameter).
    """
    return self.__maxLeaseTime
      
  def _set_maxLeaseTime(self, v, load=False):
    """
    Setter method for maxLeaseTime, mapped from YANG variable /dhcp/maxLeaseTime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maxLeaseTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maxLeaseTime() directly.

    YANG Description: The max lease time (global parameter).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maxLeaseTime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)""",
        })

    self.__maxLeaseTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maxLeaseTime(self):
    self.__maxLeaseTime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(7200), is_leaf=True, yang_name="maxLeaseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='uint32', is_config=True)


  def _get_logFacility(self):
    """
    Getter method for logFacility, mapped from YANG variable /dhcp/logFacility (loglevel)

    YANG Description: The type of program that is logging the message.
    """
    return self.__logFacility
      
  def _set_logFacility(self, v, load=False):
    """
    Setter method for logFacility, mapped from YANG variable /dhcp/logFacility (loglevel)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logFacility is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logFacility() directly.

    YANG Description: The type of program that is logging the message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'kern': {}, 'daemon': {}, 'local7': {}},), default=six.text_type("local7"), is_leaf=True, yang_name="logFacility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='loglevel', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logFacility must be of a type compatible with loglevel""",
          'defined-type': "dhcpd:loglevel",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'kern': {}, 'daemon': {}, 'local7': {}},), default=six.text_type("local7"), is_leaf=True, yang_name="logFacility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='loglevel', is_config=True)""",
        })

    self.__logFacility = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logFacility(self):
    self.__logFacility = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'kern': {}, 'daemon': {}, 'local7': {}},), default=six.text_type("local7"), is_leaf=True, yang_name="logFacility", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='loglevel', is_config=True)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /dhcp/dns (inet:ipv4-address)

    YANG Description: Domain name servers (max 2).
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /dhcp/dns (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.

    YANG Description: Domain name servers (max 2).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'})), is_leaf=False, yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='inet:ipv4-address', is_config=True)


  def _get_subNetworks(self):
    """
    Getter method for subNetworks, mapped from YANG variable /dhcp/subNetworks (container)
    """
    return self.__subNetworks
      
  def _set_subNetworks(self, v, load=False):
    """
    Setter method for subNetworks, mapped from YANG variable /dhcp/subNetworks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subNetworks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subNetworks() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subNetworks_dhcpd__dhcp_subNetworks, is_container='container', yang_name="subNetworks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subNetworks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subNetworks_dhcpd__dhcp_subNetworks, is_container='container', yang_name="subNetworks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)""",
        })

    self.__subNetworks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subNetworks(self):
    self.__subNetworks = YANGDynClass(base=yc_subNetworks_dhcpd__dhcp_subNetworks, is_container='container', yang_name="subNetworks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)

  defaultLeaseTime = __builtin__.property(_get_defaultLeaseTime, _set_defaultLeaseTime)
  maxLeaseTime = __builtin__.property(_get_maxLeaseTime, _set_maxLeaseTime)
  logFacility = __builtin__.property(_get_logFacility, _set_logFacility)
  dns = __builtin__.property(_get_dns, _set_dns)
  subNetworks = __builtin__.property(_get_subNetworks, _set_subNetworks)


  _pyangbind_elements = OrderedDict([('defaultLeaseTime', defaultLeaseTime), ('maxLeaseTime', maxLeaseTime), ('logFacility', logFacility), ('dns', dns), ('subNetworks', subNetworks), ])


class dhcpd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module dhcpd - based on the path /dhcpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions for
managing a simple DHCP server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dhcp',)

  _yang_name = 'dhcpd'
  _yang_namespace = 'http://univ-tlse3.fr/ns/dhcpd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dhcp = YANGDynClass(base=yc_dhcp_dhcpd__dhcp, is_container='container', yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_dhcp(self):
    """
    Getter method for dhcp, mapped from YANG variable /dhcp (container)

    YANG Description: DHCP server configuration.
    """
    return self.__dhcp
      
  def _set_dhcp(self, v, load=False):
    """
    Setter method for dhcp, mapped from YANG variable /dhcp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp() directly.

    YANG Description: DHCP server configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dhcp_dhcpd__dhcp, is_container='container', yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dhcp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dhcp_dhcpd__dhcp, is_container='container', yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)""",
        })

    self.__dhcp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dhcp(self):
    self.__dhcp = YANGDynClass(base=yc_dhcp_dhcpd__dhcp, is_container='container', yang_name="dhcp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://univ-tlse3.fr/ns/dhcpd', defining_module='dhcpd', yang_type='container', is_config=True)

  dhcp = __builtin__.property(_get_dhcp, _set_dhcp)


  _pyangbind_elements = OrderedDict([('dhcp', dhcp), ])


